package main

import (
	"fmt"
	"sort"
	"strings"
)

/*
Поиск анаграмм в словаре
Напишите функцию, которая находит все множества анаграмм по заданному словарю.

Требования
На вход подается срез строк (слов на русском языке в Unicode).

На выходе: map-множество -> список, где ключом является первое встреченное слово множества, а значением — срез из всех слов, принадлежащих этому множеству анаграмм, отсортированных по возрастанию.

Множества из одного слова не должны выводиться (т.е. если нет анаграмм, слово игнорируется).

Все слова нужно привести к нижнему регистру.

Пример:

Вход: ["пятак", "пятка", "тяпка", "листок", "слиток", "столик", "стол"]
Результат (ключи в примере могут быть в другом порядке):
– "пятак": ["пятак", "пятка", "тяпка"]
– "листок": ["листок", "слиток", "столик"]

Слово «стол» отсутствует в результатах, так как не имеет анаграмм.

Для решения задачи потребуется умение работать со строками, сортировать
и использовать структуры данных (map).

Оценим эффективность: решение должно работать за линейно-логарифмическое время относительно количества слов (допустимо n * m log m, где m — средняя длина слова для сортировки букв).
*/

// normalizeWord приводит слово к каноническому виду для сравнения анаграмм:
// — переводит в нижний регистр
// — сортирует буквы
func normalizeWord(word string) string {
	// Приводим к нижнему регистру
	lower := strings.ToLower(word)
	// Преобразуем в слайс рун для корректной работы с Unicode
	runes := []rune(lower)
	// Сортируем руны
	sort.Slice(runes, func(i, j int) bool {
		return runes[i] < runes[j]
	})
	// Возвращаем как строку
	return string(runes)
}

// FindAnagramGroups находит все множества анаграмм в словаре.
// Возвращает map, где ключ — первое встреченное слово из группы,
// значение — отсортированный по возрастанию список всех слов в группе.
// Группы из одного слова исключаются.
func FindAnagramGroups(words []string) map[string][]string {
	if len(words) == 0 {
		return nil
	}

	// groupsByKey: ключ — нормализованное слово, значение — список оригинальных слов (в нижнем регистре)
	groupsByKey := make(map[string][]string)
	// firstOccurrence: запоминаем первое встреченное слово для каждого нормализованного ключа
	firstOccurrence := make(map[string]string)

	for _, word := range words {
		if word == "" {
			continue
		}
		lowerWord := strings.ToLower(word)
		key := normalizeWord(word)

		// Запоминаем первое слово для этого ключа
		if _, exists := firstOccurrence[key]; !exists {
			firstOccurrence[key] = lowerWord
		}

		// Добавляем слово в группу
		groupsByKey[key] = append(groupsByKey[key], lowerWord)
	}

	// Формируем результат
	result := make(map[string][]string)

	for key, group := range groupsByKey {
		// Пропускаем группы из одного слова
		if len(group) < 2 {
			continue
		}

		// Сортируем слова в группе по возрастанию (лексикографически)
		sort.Strings(group)

		// Ключ результата — первое встреченное слово (в нижнем регистре)
		firstWord := firstOccurrence[key]
		result[firstWord] = group
	}

	return result
}

func main() {
	words := []string{"пятак", "пятка", "тяпка", "листок", "слиток", "столик", "стол"}
	result := FindAnagramGroups(words)
	fmt.Println(result)
	// Вывод (порядок может отличаться):
	// "пятак": ["пятак", "пятка", "тяпка"]
	// "листок": ["листок", "слиток", "столик"]
}
